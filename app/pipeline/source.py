from abc import abstractmethod
from typing import Dict, List, Optional, Any
from pathlib import Path
import git
from app.models.git_platform import GitPlatform
from app.models.schema_registry import SchemaRegistry
from app.utils.interfaces.ifactory import IFactory
from app.utils.normalized_pr import NormalizedPR
from app.utils.normalized_push import NormalizedPush
from concurrent.futures import ThreadPoolExecutor, as_completed

class Source(IFactory):

    @classmethod
    def load_module(cls, name: str):
        from app.pipeline import sources

        cls._load_class_from_package_module(
            module_name=name,
            package_module=sources
        )

    @abstractmethod
    def fetch(self) -> List[Any]:
        """
        Reads data from the external system (Git).
        Returns a list of raw items (e.g., tuples of content) to be processed.
        """
        pass

    @classmethod
    def create(cls, *args, **kwargs):
        platform_instance = GitPlatform.create(*args, **kwargs)
        name = kwargs.get("name")

        if name not in cls._registry:
            cls.load_module(name)

        target_cls = cls._registry.get(name)
        if not target_cls:
            raise ValueError(f"Source class '{name}' not found. Available: {list(cls._registry.keys())}")

        return target_cls(platform_instance)

    def generate_webhook_url(self, platform: str, datasource: str = None) -> str:
        if datasource:
            return f"https://smee.io/wbkMDPCrORy5Hr/webhooks/{platform}/{datasource}"
        return f"https://smee.io/wbkMDPCrORy5Hr/webhooks/schemas"

    def clone_schema_repo(self, schema: SchemaRegistry) -> "ISource":
        """
        Clones the schema repository using the URL generated by the platform settings.
        Includes Windows-safe cleanup to ensure a fresh start.
        """
        base_dir = Path("./schemas")
        target_dir = base_dir / schema.repo

        try:
            repo_url = self.settings.construct_clone_url(schema.repo)

            print(f"[{self.settings.name}] Cloning schemas from: {schema.repo}")

            git.Repo.clone_from(
                url=repo_url,
                to_path=target_dir,
                branch=schema.branch,
                depth=1
            )

        except git.exc.GitCommandError as e:
            print(f"[Git Error] Failed to clone {schema.repo}: {e}")
        except Exception as e:
            print(f"[Error] Unexpected error: {e}")

        return self

    def setup_webhooks(self, schema: SchemaRegistry, repos: List[str], datasource: str,
                       exclude_repos: List[str] = None):
        """
        Orchestrator: Authenticates, clones schema, and applies webhooks.
        Uses Standard Python Threads (Fixed Pool).
        """
        try:
            # 1. Authenticate
            self.auth()

            # 2. Handle Schema Registry Repo
            if schema.platform == self.settings.name:
                print(f"[{self.settings.name}] Managing Schema Repo: {schema.repo}")
                self.clone_schema_repo(schema)
                self.create_webhooks(schema.repo, datasource=None)

            # 3. Handle Target Repositories
            if repos:
                final_repos = [r for r in repos if r not in (exclude_repos or [])]
                count = len(final_repos)
                print(f"[{self.settings.name}] Configuring webhooks for {count} repositories (Threaded)...")

                # REPLACEMENT: Fixed pool of 10 threads
                with ThreadPoolExecutor(max_workers=10) as executor:
                    # Submit all tasks
                    future_to_repo = {
                        executor.submit(self.create_webhooks, repo, datasource): repo
                        for repo in final_repos
                    }

                    # Wait for completion and handle errors
                    for future in as_completed(future_to_repo):
                        repo = future_to_repo[future]
                        try:
                            future.result()  # This re-raises any exception caught during execution
                        except Exception as exc:
                            print(f"[{self.settings.name}] Repo {repo} generated an exception: {exc}")

            else:
                print(f"[{self.settings.name}] No target repositories provided.")

        except Exception as e:
            print(f"[{self.settings.name} Error] Setup failed: {e}")
            raise e

        finally:
            self.closed()

    # ... (Abstract methods remain unchanged) ...
    @abstractmethod
    def auth(self):
        pass

    @abstractmethod
    def closed(self):
        pass

    @abstractmethod
    def resolve_repositories(self, patterns: List[str], exclude_patterns: Optional[List[str]] = None) -> List[str]:
        pass

    @abstractmethod
    def create_webhooks(self, repositories: List[str] | str, datasource: str = None):
        pass

    @abstractmethod
    def get_file_from_commit(self, repo_name: str, commit_hash: str, file_path: str) -> Optional[str]:
        pass

    @staticmethod
    @abstractmethod
    def normalize_pr_payload(self, payload: Dict[str, Any], newest_first: bool = False) -> NormalizedPR:
        pass

    @staticmethod
    @abstractmethod
    def normalize_push_payload(payload: Dict[str, Any], file: Optional[str] = None) -> NormalizedPush:
        pass