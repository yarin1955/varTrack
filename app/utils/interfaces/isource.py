# Standard Imports
from abc import abstractmethod
from typing import Dict, List, Optional, Any
from pathlib import Path
import os
import git

# Gevent Imports (Must be patched early)
import gevent
from gevent import monkey

monkey.patch_all()  # Patches socket/ssl/threading to be async-compatible

# App Imports
from app.models.git_platform import GitPlatform
from app.models.schema_registry import SchemaRegistry
from app.utils.interfaces.ifactory import IFactory
from app.utils.normalized_pr import NormalizedPR
from app.utils.normalized_push import NormalizedPush


class ISource(IFactory):

    @classmethod
    def load_module(cls, name: str):
        from app.pipeline import sources

        cls._load_class_from_package_module(
            module_name=name,
            package_module=sources
        )

    @classmethod
    def create(cls, *args, **kwargs):
        platform_instance = GitPlatform.create(*args, **kwargs)
        name = kwargs.get("name")

        if name not in cls._registry:
            cls.load_module(name)

        target_cls = cls._registry.get(name)
        if not target_cls:
            raise ValueError(f"Source class '{name}' not found. Available: {list(cls._registry.keys())}")

        return target_cls(platform_instance)

    def generate_webhook_url(self, platform: str, datasource: str = None) -> str:
        if datasource:
            return f"https://smee.io/wbkMDPCrORy5Hr/webhooks/{platform}/{datasource}"
        return f"https://smee.io/wbkMDPCrORy5Hr/webhooks/schemas"

    def clone_schema_repo(self, schema: SchemaRegistry) -> "ISource":
        """
        Clones the schema repository using the URL generated by the platform settings.
        Includes Windows-safe cleanup to ensure a fresh start.
        """
        base_dir = Path("./schemas")
        target_dir = base_dir / schema.repo

        try:
            repo_url = self.settings.construct_clone_url(schema.repo)

            print(f"[{self.settings.name}] Cloning schemas from: {schema.repo}")

            git.Repo.clone_from(
                url=repo_url,
                to_path=target_dir,
                branch=schema.branch,
                depth=1
            )

        except git.exc.GitCommandError as e:
            print(f"[Git Error] Failed to clone {schema.repo}: {e}")
        except Exception as e:
            print(f"[Error] Unexpected error: {e}")

        return self

    def setup_webhooks(self, schema: SchemaRegistry, repos: List[str], datasource: str,
                       exclude_repos: List[str] = None):
        """
        Orchestrator: Authenticates, clones schema, and applies webhooks IN PARALLEL.
        """
        try:
            # 1. Authenticate (Main Thread - Shared Session)
            self.auth()

            # 2. Handle Schema Registry Repo (Sequential - Critical Step)
            if schema.platform == self.settings.name:
                print(f"[{self.settings.name}] Managing Schema Repo: {schema.repo}")
                self.clone_schema_repo(schema)
                self.create_webhooks(schema.repo, datasource=None)

            # 3. Handle Target Repositories (Parallel - High Performance)
            if repos:
                final_repos = [r for r in repos if r not in (exclude_repos or [])]
                count = len(final_repos)
                print(f"[{self.settings.name}] Configuring webhooks for {count} repositories (Async)...")

                # Spawn a Greenlet for each repository
                # This runs create_webhooks concurrently for every repo
                jobs = [
                    gevent.spawn(self.create_webhooks, repo, datasource)
                    for repo in final_repos
                ]

                # Wait for all jobs to finish
                gevent.joinall(jobs)

            else:
                print(f"[{self.settings.name}] No target repositories provided.")

        except Exception as e:
            print(f"[{self.settings.name} Error] Setup failed: {e}")
            raise e

        finally:
            self.closed()

    # ... (Abstract methods remain unchanged) ...
    @abstractmethod
    def auth(self):
        pass

    @abstractmethod
    def closed(self):
        pass

    @abstractmethod
    def resolve_repositories(self, patterns: List[str], exclude_patterns: Optional[List[str]] = None) -> List[str]:
        pass

    @abstractmethod
    def create_webhooks(self, repositories: List[str] | str, datasource: str = None):
        pass

    @abstractmethod
    def get_file_from_commit(self, repo_name: str, commit_hash: str, file_path: str) -> Optional[str]:
        pass

    @staticmethod
    @abstractmethod
    def normalize_pr_payload(self, payload: Dict[str, Any], newest_first: bool = False) -> NormalizedPR:
        pass

    @staticmethod
    @abstractmethod
    def normalize_push_payload(payload: Dict[str, Any], file: Optional[str] = None) -> NormalizedPush:
        pass