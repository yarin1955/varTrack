syntax = "proto3";

package vartrack.v1;

import "vartrack/v1/utils/enums.proto";
import "buf/validate/validate.proto";

message RepositoryOverride {
  repeated string match_repositories = 1;
  repeated string exclude_repositories = 2;
  bool enable = 3;
}

message Rule {
  string platform = 1 [(buf.validate.field).string.min_len = 1];
  string datasource = 2 [(buf.validate.field).string.min_len = 1];
  optional string file_name = 3;
  repeated string repositories = 4 [(buf.validate.field).repeated.min_items = 1];
  repeated string exclude_repositories = 5;

  bool env_as_branch = 6;
  bool env_as_pr = 7;
  bool env_as_tags = 8;

  map<string, string> branch_map = 9;
  map<string, string> file_path_map = 10;
  string unique_key_name = 11 [default = "{repoName}-{env}"];
  map<string, string> variables_map = 12;

  SyncMode sync_mode = 13;
  repeated RepositoryOverride overrides = 14;

  bool prune = 15;
  bool prune_last = 16;
  repeated string prune_protection = 17;
  bool dry_run_prune = 18;
  bool self_heal = 19 [default = true];
  ApplyStrategy apply_strategy = 20;

  // Complex Logic Validations
  option (buf.validate.message).cel = {
    id: "rule.scan_target",
    message: "You must provide either 'file_name' or 'file_path_map'",
    expression: "has(this.file_name) || this.file_path_map.size() > 0"
  };

  option (buf.validate.message).cel = {
    id: "rule.unique_key_env_requirement",
    message: "If unique_key_name contains '{env}', an environment strategy must be enabled",
    expression: "!this.unique_key_name.contains('{env}') || (this.env_as_branch || this.env_as_pr || this.env_as_tags || this.branch_map.size() > 0 || this.file_path_map.size() > 0)"
  };
}