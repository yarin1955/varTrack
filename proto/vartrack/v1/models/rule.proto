syntax = "proto3";

package vartrack.v1;

import "vartrack/v1/utils/enums.proto";
import "buf/validate/validate.proto";

message RepositoryOverride {
  repeated string match_repositories = 1;
  repeated string exclude_repositories = 2;
  bool enable = 3;
}

message Rule {
  string platform = 1 [(buf.validate.field).string.min_len = 1];
  string datasource = 2 [(buf.validate.field).string.min_len = 1];

  // Name of the secret manager for resolving external SecretRef fields.
  // Must match a name in bundle.secret_managers. If empty, all SecretRef
  // fields in the platform config must be inline strings.
  optional string secret_manager = 3;

  optional string file_name = 4;
  repeated string repositories = 5 [(buf.validate.field).repeated.min_items = 1];
  repeated string exclude_repositories = 6;

  bool env_as_branch = 7;
  bool env_as_pr = 8;
  bool env_as_tags = 9;
  map<string, string> branch_map = 10;
  map<string, string> file_path_map = 11;
  string unique_key_name = 12;
  map<string, string> variables_map = 13;

  SyncMode sync_mode = 14;
  repeated RepositoryOverride overrides = 15;

  bool prune = 16;
  bool prune_last = 17;
  repeated string prune_protection = 18;
  bool dry_run_prune = 19;
  bool self_heal = 20;
  ApplyStrategy apply_strategy = 21;

  option (buf.validate.message).cel = {
    id: "rule.scan_target",
    message: "You must provide either 'file_name' or 'file_path_map'",
    expression: "has(this.file_name) || this.file_path_map.size() > 0"
  };
  option (buf.validate.message).cel = {
    id: "rule.unique_key_env_requirement",
    message: "If unique_key_name contains '{env}', an environment strategy must be enabled",
    expression: "!this.unique_key_name.contains('{env}') || (this.env_as_branch || this.env_as_pr || this.env_as_tags || this.branch_map.size() > 0 || this.file_path_map.size() > 0)"
  };
}
